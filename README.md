# Head First Designpatterns
### 디자인 원칙
#### 애플리케이션에서 달라지는 부분을 찾아 내고, 달라지지 않는 부분으로부터 분리 시킨다.
- 바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있습니다.
#### 구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.
- 인터페이스에 맞춰서 프로그래밍 하라는 뜻은 상위 형식에 맞춰서 프로그래밍 해라는 뜻입니다.
#### 상속보다는 구성을 활용한다.
- 구성을 이용하여 시스템을 만들면 유연성을 크게 향상시킬 수 있도록 만들어주는 것 뿐 아니라, 구성요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행시에 행동을 바꿀 수도 있게 해 줍니다.
#### 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
- 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있습니다. 객체 사이의 상호의존성을 최소화할 수 있기 때문입니다.
#### 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.
- 옵저버 패턴을 예로 들어 옵저버를 새로 추가하면 Subject 자체에 코드를 추가하지 않으면서도 언제든지 확장할 수 있습니다.
#### 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않도록 한다.
- 팩토리 메소드 패턴의 내용을 예로 들어 아래의 피자 구상 클래스가 변경되면 PizzaStore의 내용도 바꿔야 할 수 있습니다. 고수준 구성요소가 저수준 구성요소를 의존하고 있습니다. 저수준 구성요소가 수백개라고 한다면 저수준 구성요소 하나 하나가 바뀔 때 마다 고수준 구성요소에 영향을 끼칠 수 있습니다. 
![image](https://user-images.githubusercontent.com/21019088/49995117-9bfa0600-ffce-11e8-854c-61e78b3772bd.png)
- 아래와 같이 변경하면 피자가 변경될 때 마다 PizzaStore에 영향을 끼치지 않습니다. 피자들은 하나 하나 새로운 종류로 추가되고 지워지기 쉬웠지만 그림의 인터페이스는 그렇지 않습니다. 그래서 PizzaStore와 Pizza들이 인터페이스에만 의존하면 인터페이스에게만 영향을 받습니다. 
![image](https://user-images.githubusercontent.com/21019088/49995157-b46a2080-ffce-11e8-81f7-0968b937f888.png)

※ 고수준 구성요소(PizzaStore)
- 저수준 구성요소(NYStyleCheesePizza...)에 의해 정의되는 행동이 들어있는 구성요소를 뜻합니다.

※ 이 원칙을 지키는데 도움이 될만한 가이드 라인
<ol>
  <li>어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 맙시다.</li></br>
  <li>구상 클래스에서 유도된 클래스를 만들지 맙시다.</li></br>
  <li>베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드하지 맙시다.</li></br>
</ol>

#### 정말 친한 친구하고만 얘기하라.(Principle of Least Knowledge)
- 여러 객체하고 인연을 맺는 것을 피해야 합니다. 어떤 메소드를 호출한 경과로 리턴받는 객체에 있는 메소드를 호출하면 다른 객체의 일부분에 대해서 요청을 하게 되는 것이고, 그러다 보면 직접적으로 알고 지내는 객체의 개수가 늘어나게 됩니다. 그런 경우에 최소지식 원칙을 따르려면 그 객체 쪽에서 대신 요청을 하도록 만들어야 합니다. 그러면 그 객체의 한 구성요소를 알고 지낼 필요도 없어집니다.
![image](https://user-images.githubusercontent.com/21019088/50000614-690b3e80-ffdd-11e8-9a37-2a8d460d446c.png)

※ 친구를 만들지 않으면서 다른 객체에 영향력을 행사하는 방법
- 어떤 메소드에서든지 다음 네 종류의 객체의 메소드만을 호출하면 됩니다.
<ol>
  <li>객체 자체</li></br>
  <li>메소드에 매개변수로 전달된 객체</li></br>
  <li>그 메소드에서 생성하거나 인스턴스를 만든 객체</li></br>
  <li>그 객체에 속하는 구성요소</li></br>
</ol>

#### 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.(Hollywood Principle)
- 헐리우드 원칙을 활용하면 "의존성 부패"를 방지 할 수 있습니다. 저수준 구성요소에서 시스템에 접속을 할 수는 있지만, 언제 어떤 식으로 그 구성요소들을 사용할지는 고수준 구성요소에서 결정하게 됩니다. 즉, 고수준 구성요소에서 저수준 구성요소에게 "먼저 연락하지 마세요. 제가 먼저 연락 드리겠습니다."라고 얘기를 하는 것과 같습니다. 

※ 의존성 부패
- 어떤 고수준 구성요소가 저수준 구성요소에 의존하고, 그 저수준 구성요소는 다시 고수준 구성요소에 의존하고, 그 고수준 구성요소는 다시 또 다른 구성요소에 의존하고, 그 다른 구성요소는 또 저수준 구성요소에 의존하는 것과 같은 식으로 의존성이 복잡하게 꼬여있는 것

#### 한 클래스는 한 가지 역할만 맡아야 한다.(SRP: The Single Responsibility Principle)
- 어떤 클래스에서 맡고 있는 모든 역할들은 나중에 코드 변화를 불러올 수 있습니다. 역할이 두 개 이상 있으면 바뀔 수 있는 부분이 두 가지 이상으로 한 가지의 역할을 맡는 클래스보다 많은 변화를 불러 일으킵니다.

#### 각 디자인 원칙에 대해 이해하기 쉽도록 설명 해 놓은 사이트
http://plposer.tistory.com/13

#### 결합도(Coupling)와 응집도(Cohesion) 정리 잘 되어 있는 사이트
http://lazineer.tistory.com/93
- 응집도가 높을수록 구성 요소들이 꼭 필요한 것들로만 모여 있고, 응집도가 낮을수록 서로 관련성이 적은 요소들이 모여 있다.

 ### 패턴
 <ol>
  <li>데코레이터 패턴 : 객체를 감싸서 새로운 행동을 제공합니다.</li></br>
  <li>스테이트 패턴 : 상태를 기반으로 한 행동을 캡슐화한 다음 위임을 통해서 필요한 행동을 선택합니다.</li></br>
  <li>이터레이터 패턴 : 컬렉션이 어떤 식으로 구현되었는지 드러내진 않으면서도 컬렉션 내에 있는 모든 객체에 대한 반복 작업을 처리할 수 있게 해 줍니다.</li></br>
  <li>퍼사드 패턴 : 일련의 클래스에 대해서 간단한 인터페이스를 제공합니다.</li></br>
  <li>스트래티지 패턴 : 교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정합니다.</li></br>
  <li>프록시 패턴 : 객체를 감싸서 그 객체에 대한 접근을 제어합니다.</li></br>
  <li>팩토리 메소드 패턴 : 생성할 구상 클래스를 서브클래스에서 결정합니다.</li></br>
  <li>어댑터 패턴 : 객체를 감싸서 다른 인터페이스를 제공합니다.</li></br>
  <li>옵저버 패턴 : 상태가 변경되면 다른 객체들 한테 연락을 돌릴 수 있게 해 줍니다.</li></br>
  <li>템플릿 메소드 패턴 : 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정합니다.</li></br>
  <li>컴포지트 패턴 : 클라이언트에서 객체 컬렉션과 개별 객체를 똑같이 다룰 수 있도록 해 줍니다.</li></br>
  <li>싱글턴 패턴 : 딱 한 객체만 생성되도록 합니다.</li></br>
  <li>추상 팩토리 패턴 : 클라이언트에서 구상 클래스를 지정하지 않으면서도 일군의 객체를 생성할 수 있도록 해 줍니다.</li></br>
  <li>커맨드 패턴 : 요청을 객체로 감쌉니다.</li></br>
 </ol>
 
#### 각 패턴 폴더에서 좀 더 구체적으로 설명해 놓았습니다.
 
### What is the SOLID？
- S: Single responsibility
- O: Open-closed principle
- L: Liskov substitution principle
- I: Interface segregation principle
- D: Dependency inversion

#### SOLID에 대해 요약 되어 있습니다.
https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)

#### SOLID에 대해 자세하게 설명되어 있습니다.
http://www.nextree.co.kr/p6960/


### References
https://github.com/brodieroy/Study/wiki/(U)-UML-%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%84-%EA%B4%80%EA%B3%84(association,-composition,-aggregation,-dependency)

https://gmlwjd9405.github.io/2018/07/04/class-diagram.html

https://gmlwjd9405.github.io/tags.html#%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4

http://hyeonstorage.tistory.com/category/%3D%3D%20JAVA%20%3D%3D/Design%20Patterns

http://jusungpark.tistory.com/category/DesignPattern

### P.S
- 디자인 패턴을 사용하는 것이 부적절한 경우도 종종 있습니다. 그냥 디자인 원칙만 충실히 적용해서 훨씬 간단하게 문제를 해결할 수 있는 경우가 많거든요.
